/*
 *
 * Copyright (C) 2020 University of Bamberg, Software Technologies Research Group
 * <https://www.uni-bamberg.de/>, <http://www.swt-bamberg.de/>
 *
 * This file is part of the BahnDSL project, a domain-specific language
 * for configuring and modelling model railways.
 *
 * BahnDSL is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * BahnDSL is a RESEARCH PROTOTYPE and distributed WITHOUT ANY WARRANTY, without
 * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE. See the GNU General Public License for more details.
 *
 * The following people contributed to the conception and realization of the
 * present BahnDSL (in alphabetic order by surname):
 *
 * - Tri Nguyen <https://github.com/trinnguyen>
 *
 */

/*
 * generated by Xtext 2.20.0
 */
package de.uniba.swt.dsl.generator;

import com.google.inject.Injector;
import de.uniba.swt.dsl.BahnStandaloneSetup;

import java.util.List;
import java.util.Set;
import java.util.stream.IntStream;

import de.uniba.swt.dsl.generator.cli.ArgOption;
import de.uniba.swt.dsl.generator.cli.ArgOptionContainer;
import de.uniba.swt.dsl.generator.cli.ArgParseResult;
import de.uniba.swt.dsl.generator.externals.JavaCliRuntimeExecutor;
import org.apache.log4j.Level;
import org.apache.log4j.Logger;
import org.eclipse.xtext.generator.JavaIoFileSystemAccess;

public class Main {

	private Main() {}

	public static void main(String[] args) {
		// define
		var modeDesc = String.format("code generation mode (%s, %s, %s)", StandaloneApp.MODE_DEFAULT, StandaloneApp.MODE_C_CODE, StandaloneApp.MODE_LIBRARY);
		var container = new ArgOptionContainer(List.of(
				new ArgOption("o", "output folder", true, "path"),
				new ArgOption("m", modeDesc, true, "mode"),
				new ArgOption("v", "verbose output"),
				new ArgOption("d", "debug output")));

		// parse arg
		if (args.length == 0) {
			showHelp(container, true);
			return;
		}
		ArgParseResult result;
		try {
			result = container.parse(args, 0);
		} catch (Exception e) {
			System.out.println(e.getMessage() + "\n");
			showHelp(container, false);
			return;
		}

		// load file
		var inputFile = filterArgs(args, result.getConsumedIndices());
		if (inputFile == null || inputFile.isBlank()) {
			showHelp(container,true);
			return;
		}

		// verbose
		if (result.hasOption("v")) {
			Logger.getRootLogger().setLevel(Level.INFO);
		} else {
			Logger.getRootLogger().setLevel(Level.WARN);
		}

		// development arg
		if (result.hasOption("d")) {
			Logger.getRootLogger().setLevel(Level.DEBUG);
		}

		// prepare for code generation
		String outputPath = result.getValue("o", null);
		String mode = result.getValue("m", StandaloneApp.MODE_DEFAULT);

		// process
		Injector injector = new BahnStandaloneSetup().createInjectorAndDoEMFRegistration();
		StandaloneApp app = injector.getInstance(StandaloneApp.class);
		JavaIoFileSystemAccess fsa = injector.getInstance(JavaIoFileSystemAccess.class);
		JavaCliRuntimeExecutor runtimeExec = injector.getInstance(JavaCliRuntimeExecutor.class);

		boolean success = app.runGenerator(inputFile, fsa, outputPath, mode, runtimeExec);
		if (!success) {
			System.exit(1);
		}
	}

	private static String filterArgs(String[] args, Set<Integer> consumedIndices) {
		if (args != null && args.length > 0) {
			if (consumedIndices != null) {
				var first = IntStream.range(0, args.length).filter(i -> !consumedIndices.contains(i)).findFirst();
				return first.isPresent() ? args[first.getAsInt()] : null;
			}

			return args[0];
		}

		return null;
	}

	private static void showHelp(ArgOptionContainer container, boolean showAll) {
		if (showAll) {
			System.out.println("OVERVIEW: Bahn compiler\n");
		}
		System.out.println(container.formatHelp("bahnc file"));
		System.out.println("EXAMPLE: \n" +
				"  bahnc example.bahn\n" +
				"  bahnc -m library -v example.bahn\n" +
				"  bahnc -o output/src-gen example.bahn\n");
	}
}